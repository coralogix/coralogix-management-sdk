/*


No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package connectors_service

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ConnectorsServiceAPIService ConnectorsServiceAPI service
type ConnectorsServiceAPIService service

type ApiConnectorsServiceBatchGetConnectorSummariesRequest struct {
	ctx context.Context
	ApiService *ConnectorsServiceAPIService
	connectorIds *[]string
}

func (r ApiConnectorsServiceBatchGetConnectorSummariesRequest) ConnectorIds(connectorIds []string) ApiConnectorsServiceBatchGetConnectorSummariesRequest {
	r.connectorIds = &connectorIds
	return r
}

func (r ApiConnectorsServiceBatchGetConnectorSummariesRequest) Execute() (*BatchGetConnectorSummariesResponse, *http.Response, error) {
	return r.ApiService.ConnectorsServiceBatchGetConnectorSummariesExecute(r)
}

/*
ConnectorsServiceBatchGetConnectorSummaries Batch Get Connectors Summaries

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectorsServiceBatchGetConnectorSummariesRequest
*/
func (a *ConnectorsServiceAPIService) ConnectorsServiceBatchGetConnectorSummaries(ctx context.Context) ApiConnectorsServiceBatchGetConnectorSummariesRequest {
	return ApiConnectorsServiceBatchGetConnectorSummariesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchGetConnectorSummariesResponse
func (a *ConnectorsServiceAPIService) ConnectorsServiceBatchGetConnectorSummariesExecute(r ApiConnectorsServiceBatchGetConnectorSummariesRequest) (*BatchGetConnectorSummariesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchGetConnectorSummariesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsServiceAPIService.ConnectorsServiceBatchGetConnectorSummaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/notification-center/v1/connectors:batchGetSummaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.connectorIds != nil {
		t := *r.connectorIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "connector_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "connector_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorsServiceBatchGetConnectorsRequest struct {
	ctx context.Context
	ApiService *ConnectorsServiceAPIService
	connectorIds *[]string
}

func (r ApiConnectorsServiceBatchGetConnectorsRequest) ConnectorIds(connectorIds []string) ApiConnectorsServiceBatchGetConnectorsRequest {
	r.connectorIds = &connectorIds
	return r
}

func (r ApiConnectorsServiceBatchGetConnectorsRequest) Execute() (*BatchGetConnectorsResponse, *http.Response, error) {
	return r.ApiService.ConnectorsServiceBatchGetConnectorsExecute(r)
}

/*
ConnectorsServiceBatchGetConnectors Batch Get Connectors

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectorsServiceBatchGetConnectorsRequest
*/
func (a *ConnectorsServiceAPIService) ConnectorsServiceBatchGetConnectors(ctx context.Context) ApiConnectorsServiceBatchGetConnectorsRequest {
	return ApiConnectorsServiceBatchGetConnectorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchGetConnectorsResponse
func (a *ConnectorsServiceAPIService) ConnectorsServiceBatchGetConnectorsExecute(r ApiConnectorsServiceBatchGetConnectorsRequest) (*BatchGetConnectorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchGetConnectorsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsServiceAPIService.ConnectorsServiceBatchGetConnectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/notification-center/v1/connectors:batchGet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.connectorIds != nil {
		t := *r.connectorIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "connector_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "connector_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorsServiceCreateConnectorRequest struct {
	ctx context.Context
	ApiService *ConnectorsServiceAPIService
	connector1 *Connector1
}

func (r ApiConnectorsServiceCreateConnectorRequest) Connector1(connector1 Connector1) ApiConnectorsServiceCreateConnectorRequest {
	r.connector1 = &connector1
	return r
}

func (r ApiConnectorsServiceCreateConnectorRequest) Execute() (*CreateConnectorResponse, *http.Response, error) {
	return r.ApiService.ConnectorsServiceCreateConnectorExecute(r)
}

/*
ConnectorsServiceCreateConnector Create a Connector

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectorsServiceCreateConnectorRequest
*/
func (a *ConnectorsServiceAPIService) ConnectorsServiceCreateConnector(ctx context.Context) ApiConnectorsServiceCreateConnectorRequest {
	return ApiConnectorsServiceCreateConnectorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateConnectorResponse
func (a *ConnectorsServiceAPIService) ConnectorsServiceCreateConnectorExecute(r ApiConnectorsServiceCreateConnectorRequest) (*CreateConnectorResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateConnectorResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsServiceAPIService.ConnectorsServiceCreateConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/notification-center/v1/connectors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connector1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorsServiceDeleteConnectorRequest struct {
	ctx context.Context
	ApiService *ConnectorsServiceAPIService
	id string
}

func (r ApiConnectorsServiceDeleteConnectorRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ConnectorsServiceDeleteConnectorExecute(r)
}

/*
ConnectorsServiceDeleteConnector Delete a Connector

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiConnectorsServiceDeleteConnectorRequest
*/
func (a *ConnectorsServiceAPIService) ConnectorsServiceDeleteConnector(ctx context.Context, id string) ApiConnectorsServiceDeleteConnectorRequest {
	return ApiConnectorsServiceDeleteConnectorRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectorsServiceAPIService) ConnectorsServiceDeleteConnectorExecute(r ApiConnectorsServiceDeleteConnectorRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsServiceAPIService.ConnectorsServiceDeleteConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/notification-center/v1/connectors/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorsServiceGetConnectorRequest struct {
	ctx context.Context
	ApiService *ConnectorsServiceAPIService
	id string
}

func (r ApiConnectorsServiceGetConnectorRequest) Execute() (*GetConnectorResponse, *http.Response, error) {
	return r.ApiService.ConnectorsServiceGetConnectorExecute(r)
}

/*
ConnectorsServiceGetConnector Get a Connector

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiConnectorsServiceGetConnectorRequest
*/
func (a *ConnectorsServiceAPIService) ConnectorsServiceGetConnector(ctx context.Context, id string) ApiConnectorsServiceGetConnectorRequest {
	return ApiConnectorsServiceGetConnectorRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetConnectorResponse
func (a *ConnectorsServiceAPIService) ConnectorsServiceGetConnectorExecute(r ApiConnectorsServiceGetConnectorRequest) (*GetConnectorResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetConnectorResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsServiceAPIService.ConnectorsServiceGetConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/notification-center/v1/connectors/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorsServiceGetConnectorTypeSummariesRequest struct {
	ctx context.Context
	ApiService *ConnectorsServiceAPIService
	supportedByEntityType *string
}

func (r ApiConnectorsServiceGetConnectorTypeSummariesRequest) SupportedByEntityType(supportedByEntityType string) ApiConnectorsServiceGetConnectorTypeSummariesRequest {
	r.supportedByEntityType = &supportedByEntityType
	return r
}

func (r ApiConnectorsServiceGetConnectorTypeSummariesRequest) Execute() (*GetConnectorTypeSummariesResponse, *http.Response, error) {
	return r.ApiService.ConnectorsServiceGetConnectorTypeSummariesExecute(r)
}

/*
ConnectorsServiceGetConnectorTypeSummaries Get Connector Type Summaries

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectorsServiceGetConnectorTypeSummariesRequest
*/
func (a *ConnectorsServiceAPIService) ConnectorsServiceGetConnectorTypeSummaries(ctx context.Context) ApiConnectorsServiceGetConnectorTypeSummariesRequest {
	return ApiConnectorsServiceGetConnectorTypeSummariesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetConnectorTypeSummariesResponse
func (a *ConnectorsServiceAPIService) ConnectorsServiceGetConnectorTypeSummariesExecute(r ApiConnectorsServiceGetConnectorTypeSummariesRequest) (*GetConnectorTypeSummariesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetConnectorTypeSummariesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsServiceAPIService.ConnectorsServiceGetConnectorTypeSummaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/notification-center/v1/connectors:getTypeSummaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.supportedByEntityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supported_by_entity_type", r.supportedByEntityType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorsServiceListConnectorSummariesRequest struct {
	ctx context.Context
	ApiService *ConnectorsServiceAPIService
	connectorType *string
	supportedByEntityType *string
}

func (r ApiConnectorsServiceListConnectorSummariesRequest) ConnectorType(connectorType string) ApiConnectorsServiceListConnectorSummariesRequest {
	r.connectorType = &connectorType
	return r
}

func (r ApiConnectorsServiceListConnectorSummariesRequest) SupportedByEntityType(supportedByEntityType string) ApiConnectorsServiceListConnectorSummariesRequest {
	r.supportedByEntityType = &supportedByEntityType
	return r
}

func (r ApiConnectorsServiceListConnectorSummariesRequest) Execute() (*ListConnectorSummariesResponse, *http.Response, error) {
	return r.ApiService.ConnectorsServiceListConnectorSummariesExecute(r)
}

/*
ConnectorsServiceListConnectorSummaries List Connector Summaries

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectorsServiceListConnectorSummariesRequest
*/
func (a *ConnectorsServiceAPIService) ConnectorsServiceListConnectorSummaries(ctx context.Context) ApiConnectorsServiceListConnectorSummariesRequest {
	return ApiConnectorsServiceListConnectorSummariesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListConnectorSummariesResponse
func (a *ConnectorsServiceAPIService) ConnectorsServiceListConnectorSummariesExecute(r ApiConnectorsServiceListConnectorSummariesRequest) (*ListConnectorSummariesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListConnectorSummariesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsServiceAPIService.ConnectorsServiceListConnectorSummaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/notification-center/v1/connectors:listSummaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.connectorType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connector_type", r.connectorType, "form", "")
	}
	if r.supportedByEntityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supported_by_entity_type", r.supportedByEntityType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorsServiceListConnectorsRequest struct {
	ctx context.Context
	ApiService *ConnectorsServiceAPIService
	connectorType *string
	supportedByEntityType *string
}

func (r ApiConnectorsServiceListConnectorsRequest) ConnectorType(connectorType string) ApiConnectorsServiceListConnectorsRequest {
	r.connectorType = &connectorType
	return r
}

func (r ApiConnectorsServiceListConnectorsRequest) SupportedByEntityType(supportedByEntityType string) ApiConnectorsServiceListConnectorsRequest {
	r.supportedByEntityType = &supportedByEntityType
	return r
}

func (r ApiConnectorsServiceListConnectorsRequest) Execute() (*ListConnectorsResponse, *http.Response, error) {
	return r.ApiService.ConnectorsServiceListConnectorsExecute(r)
}

/*
ConnectorsServiceListConnectors List Connectors

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectorsServiceListConnectorsRequest
*/
func (a *ConnectorsServiceAPIService) ConnectorsServiceListConnectors(ctx context.Context) ApiConnectorsServiceListConnectorsRequest {
	return ApiConnectorsServiceListConnectorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListConnectorsResponse
func (a *ConnectorsServiceAPIService) ConnectorsServiceListConnectorsExecute(r ApiConnectorsServiceListConnectorsRequest) (*ListConnectorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListConnectorsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsServiceAPIService.ConnectorsServiceListConnectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/notification-center/v1/connectors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.connectorType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connector_type", r.connectorType, "form", "")
	}
	if r.supportedByEntityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supported_by_entity_type", r.supportedByEntityType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorsServiceReplaceConnectorRequest struct {
	ctx context.Context
	ApiService *ConnectorsServiceAPIService
	connector1 *Connector1
}

func (r ApiConnectorsServiceReplaceConnectorRequest) Connector1(connector1 Connector1) ApiConnectorsServiceReplaceConnectorRequest {
	r.connector1 = &connector1
	return r
}

func (r ApiConnectorsServiceReplaceConnectorRequest) Execute() (*ReplaceConnectorResponse, *http.Response, error) {
	return r.ApiService.ConnectorsServiceReplaceConnectorExecute(r)
}

/*
ConnectorsServiceReplaceConnector Replace a Connector

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectorsServiceReplaceConnectorRequest
*/
func (a *ConnectorsServiceAPIService) ConnectorsServiceReplaceConnector(ctx context.Context) ApiConnectorsServiceReplaceConnectorRequest {
	return ApiConnectorsServiceReplaceConnectorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReplaceConnectorResponse
func (a *ConnectorsServiceAPIService) ConnectorsServiceReplaceConnectorExecute(r ApiConnectorsServiceReplaceConnectorRequest) (*ReplaceConnectorResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReplaceConnectorResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsServiceAPIService.ConnectorsServiceReplaceConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/notification-center/v1/connector"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connector1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
