/*


No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package alert_scheduler_rule_service

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AlertSchedulerRuleServiceAPIService AlertSchedulerRuleServiceAPI service
type AlertSchedulerRuleServiceAPIService service

type ApiAlertSchedulerRuleServiceCreateAlertSchedulerRuleRequest struct {
	ctx context.Context
	ApiService *AlertSchedulerRuleServiceAPIService
	createAlertSchedulerRuleRequestDataStructure *CreateAlertSchedulerRuleRequestDataStructure
}

func (r ApiAlertSchedulerRuleServiceCreateAlertSchedulerRuleRequest) CreateAlertSchedulerRuleRequestDataStructure(createAlertSchedulerRuleRequestDataStructure CreateAlertSchedulerRuleRequestDataStructure) ApiAlertSchedulerRuleServiceCreateAlertSchedulerRuleRequest {
	r.createAlertSchedulerRuleRequestDataStructure = &createAlertSchedulerRuleRequestDataStructure
	return r
}

func (r ApiAlertSchedulerRuleServiceCreateAlertSchedulerRuleRequest) Execute() (*CreateAlertSchedulerRuleResponse, *http.Response, error) {
	return r.ApiService.AlertSchedulerRuleServiceCreateAlertSchedulerRuleExecute(r)
}

/*
AlertSchedulerRuleServiceCreateAlertSchedulerRule Create an alert scheduler rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertSchedulerRuleServiceCreateAlertSchedulerRuleRequest
*/
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceCreateAlertSchedulerRule(ctx context.Context) ApiAlertSchedulerRuleServiceCreateAlertSchedulerRuleRequest {
	return ApiAlertSchedulerRuleServiceCreateAlertSchedulerRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAlertSchedulerRuleResponse
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceCreateAlertSchedulerRuleExecute(r ApiAlertSchedulerRuleServiceCreateAlertSchedulerRuleRequest) (*CreateAlertSchedulerRuleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAlertSchedulerRuleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertSchedulerRuleServiceAPIService.AlertSchedulerRuleServiceCreateAlertSchedulerRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alert-scheduler-rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAlertSchedulerRuleRequestDataStructure
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertSchedulerRuleServiceCreateBulkAlertSchedulerRuleRequest struct {
	ctx context.Context
	ApiService *AlertSchedulerRuleServiceAPIService
	createBulkAlertSchedulerRuleRequestDataStructure *CreateBulkAlertSchedulerRuleRequestDataStructure
}

func (r ApiAlertSchedulerRuleServiceCreateBulkAlertSchedulerRuleRequest) CreateBulkAlertSchedulerRuleRequestDataStructure(createBulkAlertSchedulerRuleRequestDataStructure CreateBulkAlertSchedulerRuleRequestDataStructure) ApiAlertSchedulerRuleServiceCreateBulkAlertSchedulerRuleRequest {
	r.createBulkAlertSchedulerRuleRequestDataStructure = &createBulkAlertSchedulerRuleRequestDataStructure
	return r
}

func (r ApiAlertSchedulerRuleServiceCreateBulkAlertSchedulerRuleRequest) Execute() (*CreateBulkAlertSchedulerRuleResponse, *http.Response, error) {
	return r.ApiService.AlertSchedulerRuleServiceCreateBulkAlertSchedulerRuleExecute(r)
}

/*
AlertSchedulerRuleServiceCreateBulkAlertSchedulerRule Create multiple alert scheduler rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertSchedulerRuleServiceCreateBulkAlertSchedulerRuleRequest
*/
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceCreateBulkAlertSchedulerRule(ctx context.Context) ApiAlertSchedulerRuleServiceCreateBulkAlertSchedulerRuleRequest {
	return ApiAlertSchedulerRuleServiceCreateBulkAlertSchedulerRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateBulkAlertSchedulerRuleResponse
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceCreateBulkAlertSchedulerRuleExecute(r ApiAlertSchedulerRuleServiceCreateBulkAlertSchedulerRuleRequest) (*CreateBulkAlertSchedulerRuleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateBulkAlertSchedulerRuleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertSchedulerRuleServiceAPIService.AlertSchedulerRuleServiceCreateBulkAlertSchedulerRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alert-scheduler-rules/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createBulkAlertSchedulerRuleRequestDataStructure
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertSchedulerRuleServiceDeleteAlertSchedulerRuleRequest struct {
	ctx context.Context
	ApiService *AlertSchedulerRuleServiceAPIService
	alertSchedulerRuleId string
}

func (r ApiAlertSchedulerRuleServiceDeleteAlertSchedulerRuleRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AlertSchedulerRuleServiceDeleteAlertSchedulerRuleExecute(r)
}

/*
AlertSchedulerRuleServiceDeleteAlertSchedulerRule Delete an alert scheduler rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertSchedulerRuleId
 @return ApiAlertSchedulerRuleServiceDeleteAlertSchedulerRuleRequest
*/
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceDeleteAlertSchedulerRule(ctx context.Context, alertSchedulerRuleId string) ApiAlertSchedulerRuleServiceDeleteAlertSchedulerRuleRequest {
	return ApiAlertSchedulerRuleServiceDeleteAlertSchedulerRuleRequest{
		ApiService: a,
		ctx: ctx,
		alertSchedulerRuleId: alertSchedulerRuleId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceDeleteAlertSchedulerRuleExecute(r ApiAlertSchedulerRuleServiceDeleteAlertSchedulerRuleRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertSchedulerRuleServiceAPIService.AlertSchedulerRuleServiceDeleteAlertSchedulerRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alert-scheduler-rules/{alert_scheduler_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"alert_scheduler_rule_id"+"}", url.PathEscape(parameterValueToString(r.alertSchedulerRuleId, "alertSchedulerRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertSchedulerRuleServiceGetAlertSchedulerRuleRequest struct {
	ctx context.Context
	ApiService *AlertSchedulerRuleServiceAPIService
	alertSchedulerRuleId string
}

func (r ApiAlertSchedulerRuleServiceGetAlertSchedulerRuleRequest) Execute() (*GetAlertSchedulerRuleResponse, *http.Response, error) {
	return r.ApiService.AlertSchedulerRuleServiceGetAlertSchedulerRuleExecute(r)
}

/*
AlertSchedulerRuleServiceGetAlertSchedulerRule Get an alert scheduler rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertSchedulerRuleId
 @return ApiAlertSchedulerRuleServiceGetAlertSchedulerRuleRequest
*/
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceGetAlertSchedulerRule(ctx context.Context, alertSchedulerRuleId string) ApiAlertSchedulerRuleServiceGetAlertSchedulerRuleRequest {
	return ApiAlertSchedulerRuleServiceGetAlertSchedulerRuleRequest{
		ApiService: a,
		ctx: ctx,
		alertSchedulerRuleId: alertSchedulerRuleId,
	}
}

// Execute executes the request
//  @return GetAlertSchedulerRuleResponse
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceGetAlertSchedulerRuleExecute(r ApiAlertSchedulerRuleServiceGetAlertSchedulerRuleRequest) (*GetAlertSchedulerRuleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAlertSchedulerRuleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertSchedulerRuleServiceAPIService.AlertSchedulerRuleServiceGetAlertSchedulerRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alert-scheduler-rules/{alert_scheduler_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"alert_scheduler_rule_id"+"}", url.PathEscape(parameterValueToString(r.alertSchedulerRuleId, "alertSchedulerRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest struct {
	ctx context.Context
	ApiService *AlertSchedulerRuleServiceAPIService
	activeTimeframe *AlertSchedulerRuleServiceGetBulkAlertSchedulerRuleActiveTimeframeParameter
	enabled *bool
	alertSchedulerRulesIds *AlertSchedulerRuleServiceGetBulkAlertSchedulerRuleAlertSchedulerRulesIdsParameter
	nextPageToken *string
}

func (r ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest) ActiveTimeframe(activeTimeframe AlertSchedulerRuleServiceGetBulkAlertSchedulerRuleActiveTimeframeParameter) ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest {
	r.activeTimeframe = &activeTimeframe
	return r
}

func (r ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest) Enabled(enabled bool) ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest {
	r.enabled = &enabled
	return r
}

func (r ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest) AlertSchedulerRulesIds(alertSchedulerRulesIds AlertSchedulerRuleServiceGetBulkAlertSchedulerRuleAlertSchedulerRulesIdsParameter) ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest {
	r.alertSchedulerRulesIds = &alertSchedulerRulesIds
	return r
}

func (r ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest) NextPageToken(nextPageToken string) ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest {
	r.nextPageToken = &nextPageToken
	return r
}

func (r ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest) Execute() (*GetBulkAlertSchedulerRuleResponse, *http.Response, error) {
	return r.ApiService.AlertSchedulerRuleServiceGetBulkAlertSchedulerRuleExecute(r)
}

/*
AlertSchedulerRuleServiceGetBulkAlertSchedulerRule Get multiple alert scheduler rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest
*/
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceGetBulkAlertSchedulerRule(ctx context.Context) ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest {
	return ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBulkAlertSchedulerRuleResponse
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceGetBulkAlertSchedulerRuleExecute(r ApiAlertSchedulerRuleServiceGetBulkAlertSchedulerRuleRequest) (*GetBulkAlertSchedulerRuleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBulkAlertSchedulerRuleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertSchedulerRuleServiceAPIService.AlertSchedulerRuleServiceGetBulkAlertSchedulerRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alert-scheduler-rules/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.activeTimeframe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active_timeframe", r.activeTimeframe, "form", "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "form", "")
	}
	if r.alertSchedulerRulesIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alert_scheduler_rules_ids", r.alertSchedulerRulesIds, "form", "")
	}
	if r.nextPageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_page_token", r.nextPageToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertSchedulerRuleServiceUpdateAlertSchedulerRuleRequest struct {
	ctx context.Context
	ApiService *AlertSchedulerRuleServiceAPIService
	updateAlertSchedulerRuleRequestDataStructure *UpdateAlertSchedulerRuleRequestDataStructure
}

func (r ApiAlertSchedulerRuleServiceUpdateAlertSchedulerRuleRequest) UpdateAlertSchedulerRuleRequestDataStructure(updateAlertSchedulerRuleRequestDataStructure UpdateAlertSchedulerRuleRequestDataStructure) ApiAlertSchedulerRuleServiceUpdateAlertSchedulerRuleRequest {
	r.updateAlertSchedulerRuleRequestDataStructure = &updateAlertSchedulerRuleRequestDataStructure
	return r
}

func (r ApiAlertSchedulerRuleServiceUpdateAlertSchedulerRuleRequest) Execute() (*UpdateAlertSchedulerRuleResponse, *http.Response, error) {
	return r.ApiService.AlertSchedulerRuleServiceUpdateAlertSchedulerRuleExecute(r)
}

/*
AlertSchedulerRuleServiceUpdateAlertSchedulerRule Update an alert scheduler rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertSchedulerRuleServiceUpdateAlertSchedulerRuleRequest
*/
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceUpdateAlertSchedulerRule(ctx context.Context) ApiAlertSchedulerRuleServiceUpdateAlertSchedulerRuleRequest {
	return ApiAlertSchedulerRuleServiceUpdateAlertSchedulerRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateAlertSchedulerRuleResponse
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceUpdateAlertSchedulerRuleExecute(r ApiAlertSchedulerRuleServiceUpdateAlertSchedulerRuleRequest) (*UpdateAlertSchedulerRuleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAlertSchedulerRuleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertSchedulerRuleServiceAPIService.AlertSchedulerRuleServiceUpdateAlertSchedulerRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alert-scheduler-rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAlertSchedulerRuleRequestDataStructure
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertSchedulerRuleServiceUpdateBulkAlertSchedulerRuleRequest struct {
	ctx context.Context
	ApiService *AlertSchedulerRuleServiceAPIService
	updateBulkAlertSchedulerRuleRequestDataStructure *UpdateBulkAlertSchedulerRuleRequestDataStructure
}

func (r ApiAlertSchedulerRuleServiceUpdateBulkAlertSchedulerRuleRequest) UpdateBulkAlertSchedulerRuleRequestDataStructure(updateBulkAlertSchedulerRuleRequestDataStructure UpdateBulkAlertSchedulerRuleRequestDataStructure) ApiAlertSchedulerRuleServiceUpdateBulkAlertSchedulerRuleRequest {
	r.updateBulkAlertSchedulerRuleRequestDataStructure = &updateBulkAlertSchedulerRuleRequestDataStructure
	return r
}

func (r ApiAlertSchedulerRuleServiceUpdateBulkAlertSchedulerRuleRequest) Execute() (*UpdateBulkAlertSchedulerRuleResponse, *http.Response, error) {
	return r.ApiService.AlertSchedulerRuleServiceUpdateBulkAlertSchedulerRuleExecute(r)
}

/*
AlertSchedulerRuleServiceUpdateBulkAlertSchedulerRule Update multiple alert scheduler rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertSchedulerRuleServiceUpdateBulkAlertSchedulerRuleRequest
*/
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceUpdateBulkAlertSchedulerRule(ctx context.Context) ApiAlertSchedulerRuleServiceUpdateBulkAlertSchedulerRuleRequest {
	return ApiAlertSchedulerRuleServiceUpdateBulkAlertSchedulerRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateBulkAlertSchedulerRuleResponse
func (a *AlertSchedulerRuleServiceAPIService) AlertSchedulerRuleServiceUpdateBulkAlertSchedulerRuleExecute(r ApiAlertSchedulerRuleServiceUpdateBulkAlertSchedulerRuleRequest) (*UpdateBulkAlertSchedulerRuleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateBulkAlertSchedulerRuleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertSchedulerRuleServiceAPIService.AlertSchedulerRuleServiceUpdateBulkAlertSchedulerRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alert-scheduler-rules/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateBulkAlertSchedulerRuleRequestDataStructure
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
