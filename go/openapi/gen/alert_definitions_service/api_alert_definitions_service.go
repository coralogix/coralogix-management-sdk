/*


No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package alert_definitions_service

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AlertDefinitionsServiceAPIService AlertDefinitionsServiceAPI service
type AlertDefinitionsServiceAPIService service

type ApiAlertDefsServiceBulkReplaceAlertDefsRequest struct {
	ctx context.Context
	ApiService *AlertDefinitionsServiceAPIService
	bulkReplaceAlertDefinitionsRequest *BulkReplaceAlertDefinitionsRequest
}

func (r ApiAlertDefsServiceBulkReplaceAlertDefsRequest) BulkReplaceAlertDefinitionsRequest(bulkReplaceAlertDefinitionsRequest BulkReplaceAlertDefinitionsRequest) ApiAlertDefsServiceBulkReplaceAlertDefsRequest {
	r.bulkReplaceAlertDefinitionsRequest = &bulkReplaceAlertDefinitionsRequest
	return r
}

func (r ApiAlertDefsServiceBulkReplaceAlertDefsRequest) Execute() (*BulkReplaceAlertDefsResponse, *http.Response, error) {
	return r.ApiService.AlertDefsServiceBulkReplaceAlertDefsExecute(r)
}

/*
AlertDefsServiceBulkReplaceAlertDefs Bulk replace alert definitions

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertDefsServiceBulkReplaceAlertDefsRequest
*/
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceBulkReplaceAlertDefs(ctx context.Context) ApiAlertDefsServiceBulkReplaceAlertDefsRequest {
	return ApiAlertDefsServiceBulkReplaceAlertDefsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkReplaceAlertDefsResponse
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceBulkReplaceAlertDefsExecute(r ApiAlertDefsServiceBulkReplaceAlertDefsRequest) (*BulkReplaceAlertDefsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkReplaceAlertDefsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertDefinitionsServiceAPIService.AlertDefsServiceBulkReplaceAlertDefs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/alerts/v3/all/replace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkReplaceAlertDefinitionsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertDefsServiceCreateAlertDefRequest struct {
	ctx context.Context
	ApiService *AlertDefinitionsServiceAPIService
	createAlertDefinitionRequest *CreateAlertDefinitionRequest
}

func (r ApiAlertDefsServiceCreateAlertDefRequest) CreateAlertDefinitionRequest(createAlertDefinitionRequest CreateAlertDefinitionRequest) ApiAlertDefsServiceCreateAlertDefRequest {
	r.createAlertDefinitionRequest = &createAlertDefinitionRequest
	return r
}

func (r ApiAlertDefsServiceCreateAlertDefRequest) Execute() (*CreateAlertDefResponse, *http.Response, error) {
	return r.ApiService.AlertDefsServiceCreateAlertDefExecute(r)
}

/*
AlertDefsServiceCreateAlertDef Create an alert

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertDefsServiceCreateAlertDefRequest
*/
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceCreateAlertDef(ctx context.Context) ApiAlertDefsServiceCreateAlertDefRequest {
	return ApiAlertDefsServiceCreateAlertDefRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAlertDefResponse
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceCreateAlertDefExecute(r ApiAlertDefsServiceCreateAlertDefRequest) (*CreateAlertDefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAlertDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertDefinitionsServiceAPIService.AlertDefsServiceCreateAlertDef")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/alerts/v3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAlertDefinitionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertDefsServiceDeleteAlertDefRequest struct {
	ctx context.Context
	ApiService *AlertDefinitionsServiceAPIService
	id string
}

func (r ApiAlertDefsServiceDeleteAlertDefRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AlertDefsServiceDeleteAlertDefExecute(r)
}

/*
AlertDefsServiceDeleteAlertDef DeleteAlertDef

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAlertDefsServiceDeleteAlertDefRequest
*/
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceDeleteAlertDef(ctx context.Context, id string) ApiAlertDefsServiceDeleteAlertDefRequest {
	return ApiAlertDefsServiceDeleteAlertDefRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceDeleteAlertDefExecute(r ApiAlertDefsServiceDeleteAlertDefRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertDefinitionsServiceAPIService.AlertDefsServiceDeleteAlertDef")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/alerts/v3/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertDefsServiceDownloadAlertsRequest struct {
	ctx context.Context
	ApiService *AlertDefinitionsServiceAPIService
}

func (r ApiAlertDefsServiceDownloadAlertsRequest) Execute() (*DownloadAlertsResponse, *http.Response, error) {
	return r.ApiService.AlertDefsServiceDownloadAlertsExecute(r)
}

/*
AlertDefsServiceDownloadAlerts Download alerts

Download a list of all accessible alert definitions in base64-encoded byte format.

Requires the following permissions:
- `alerts:ReadConfig`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertDefsServiceDownloadAlertsRequest
*/
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceDownloadAlerts(ctx context.Context) ApiAlertDefsServiceDownloadAlertsRequest {
	return ApiAlertDefsServiceDownloadAlertsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DownloadAlertsResponse
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceDownloadAlertsExecute(r ApiAlertDefsServiceDownloadAlertsRequest) (*DownloadAlertsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DownloadAlertsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertDefinitionsServiceAPIService.AlertDefsServiceDownloadAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/alerts/v3/all/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertDefsServiceFilterOptionCountsRequest struct {
	ctx context.Context
	ApiService *AlertDefinitionsServiceAPIService
	queryFilter *FilterOptionCountsFilter
}

func (r ApiAlertDefsServiceFilterOptionCountsRequest) QueryFilter(queryFilter FilterOptionCountsFilter) ApiAlertDefsServiceFilterOptionCountsRequest {
	r.queryFilter = &queryFilter
	return r
}

func (r ApiAlertDefsServiceFilterOptionCountsRequest) Execute() (*FilterOptionCountsResponse, *http.Response, error) {
	return r.ApiService.AlertDefsServiceFilterOptionCountsExecute(r)
}

/*
AlertDefsServiceFilterOptionCounts Get counts for filter options

Returns counts for different filter options based on the provided filters

Requires the following permissions:
- `alerts:ReadConfig`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertDefsServiceFilterOptionCountsRequest
*/
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceFilterOptionCounts(ctx context.Context) ApiAlertDefsServiceFilterOptionCountsRequest {
	return ApiAlertDefsServiceFilterOptionCountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilterOptionCountsResponse
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceFilterOptionCountsExecute(r ApiAlertDefsServiceFilterOptionCountsRequest) (*FilterOptionCountsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilterOptionCountsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertDefinitionsServiceAPIService.AlertDefsServiceFilterOptionCounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/alerts/v3/all/counts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.queryFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query_filter", r.queryFilter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertDefsServiceGetAlertDefRequest struct {
	ctx context.Context
	ApiService *AlertDefinitionsServiceAPIService
	id string
}

func (r ApiAlertDefsServiceGetAlertDefRequest) Execute() (*GetAlertDefResponse, *http.Response, error) {
	return r.ApiService.AlertDefsServiceGetAlertDefExecute(r)
}

/*
AlertDefsServiceGetAlertDef Get alert definition by ID

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAlertDefsServiceGetAlertDefRequest
*/
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceGetAlertDef(ctx context.Context, id string) ApiAlertDefsServiceGetAlertDefRequest {
	return ApiAlertDefsServiceGetAlertDefRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetAlertDefResponse
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceGetAlertDefExecute(r ApiAlertDefsServiceGetAlertDefRequest) (*GetAlertDefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAlertDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertDefinitionsServiceAPIService.AlertDefsServiceGetAlertDef")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/alerts/v3/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertDefsServiceGetAlertDefByVersionIdRequest struct {
	ctx context.Context
	ApiService *AlertDefinitionsServiceAPIService
	alertVersionId string
}

func (r ApiAlertDefsServiceGetAlertDefByVersionIdRequest) Execute() (*GetAlertDefByVersionIdResponse, *http.Response, error) {
	return r.ApiService.AlertDefsServiceGetAlertDefByVersionIdExecute(r)
}

/*
AlertDefsServiceGetAlertDefByVersionId Get alert definition by alert version ID

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertVersionId
 @return ApiAlertDefsServiceGetAlertDefByVersionIdRequest
*/
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceGetAlertDefByVersionId(ctx context.Context, alertVersionId string) ApiAlertDefsServiceGetAlertDefByVersionIdRequest {
	return ApiAlertDefsServiceGetAlertDefByVersionIdRequest{
		ApiService: a,
		ctx: ctx,
		alertVersionId: alertVersionId,
	}
}

// Execute executes the request
//  @return GetAlertDefByVersionIdResponse
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceGetAlertDefByVersionIdExecute(r ApiAlertDefsServiceGetAlertDefByVersionIdRequest) (*GetAlertDefByVersionIdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAlertDefByVersionIdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertDefinitionsServiceAPIService.AlertDefsServiceGetAlertDefByVersionId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/alerts/v3/version-ids/{alert_version_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"alert_version_id"+"}", url.PathEscape(parameterValueToString(r.alertVersionId, "alertVersionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertDefsServiceListAlertDefsRequest struct {
	ctx context.Context
	ApiService *AlertDefinitionsServiceAPIService
	queryFilter *AlertDefQueryFilter
	pagination *AlertDefsServiceListAlertDefsPaginationParameter
	orderBys *AlertDefinitionOrderByList
}

func (r ApiAlertDefsServiceListAlertDefsRequest) QueryFilter(queryFilter AlertDefQueryFilter) ApiAlertDefsServiceListAlertDefsRequest {
	r.queryFilter = &queryFilter
	return r
}

func (r ApiAlertDefsServiceListAlertDefsRequest) Pagination(pagination AlertDefsServiceListAlertDefsPaginationParameter) ApiAlertDefsServiceListAlertDefsRequest {
	r.pagination = &pagination
	return r
}

func (r ApiAlertDefsServiceListAlertDefsRequest) OrderBys(orderBys AlertDefinitionOrderByList) ApiAlertDefsServiceListAlertDefsRequest {
	r.orderBys = &orderBys
	return r
}

func (r ApiAlertDefsServiceListAlertDefsRequest) Execute() (*ListAlertDefsResponse, *http.Response, error) {
	return r.ApiService.AlertDefsServiceListAlertDefsExecute(r)
}

/*
AlertDefsServiceListAlertDefs Get a list of all accessible alert definitions

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertDefsServiceListAlertDefsRequest
*/
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceListAlertDefs(ctx context.Context) ApiAlertDefsServiceListAlertDefsRequest {
	return ApiAlertDefsServiceListAlertDefsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAlertDefsResponse
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceListAlertDefsExecute(r ApiAlertDefsServiceListAlertDefsRequest) (*ListAlertDefsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAlertDefsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertDefinitionsServiceAPIService.AlertDefsServiceListAlertDefs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/alerts/v3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.queryFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query_filter", r.queryFilter, "form", "")
	}
	if r.pagination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagination", r.pagination, "form", "")
	}
	if r.orderBys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_bys", r.orderBys, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertDefsServiceReplaceAlertDefRequest struct {
	ctx context.Context
	ApiService *AlertDefinitionsServiceAPIService
	replaceAlertDefinitionRequest *ReplaceAlertDefinitionRequest
}

func (r ApiAlertDefsServiceReplaceAlertDefRequest) ReplaceAlertDefinitionRequest(replaceAlertDefinitionRequest ReplaceAlertDefinitionRequest) ApiAlertDefsServiceReplaceAlertDefRequest {
	r.replaceAlertDefinitionRequest = &replaceAlertDefinitionRequest
	return r
}

func (r ApiAlertDefsServiceReplaceAlertDefRequest) Execute() (*ReplaceAlertDefResponse, *http.Response, error) {
	return r.ApiService.AlertDefsServiceReplaceAlertDefExecute(r)
}

/*
AlertDefsServiceReplaceAlertDef Replace an alert definition

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAlertDefsServiceReplaceAlertDefRequest
*/
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceReplaceAlertDef(ctx context.Context) ApiAlertDefsServiceReplaceAlertDefRequest {
	return ApiAlertDefsServiceReplaceAlertDefRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReplaceAlertDefResponse
func (a *AlertDefinitionsServiceAPIService) AlertDefsServiceReplaceAlertDefExecute(r ApiAlertDefsServiceReplaceAlertDefRequest) (*ReplaceAlertDefResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReplaceAlertDefResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertDefinitionsServiceAPIService.AlertDefsServiceReplaceAlertDef")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts/alerts/v3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.replaceAlertDefinitionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
