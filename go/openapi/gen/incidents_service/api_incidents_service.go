/*


No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package incidents_service

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// IncidentsServiceAPIService IncidentsServiceAPI service
type IncidentsServiceAPIService service

type ApiIncidentsServiceAcknowledgeIncidentByEventIdRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	eventId string
}

func (r ApiIncidentsServiceAcknowledgeIncidentByEventIdRequest) Execute() (*AcknowledgeIncidentByEventIdResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceAcknowledgeIncidentByEventIdExecute(r)
}

/*
IncidentsServiceAcknowledgeIncidentByEventId Acknowledge incident by event id

Mark incident as acknowledged by event id.

Requires the following permissions:
- `incidents:acknowledge`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId
 @return ApiIncidentsServiceAcknowledgeIncidentByEventIdRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceAcknowledgeIncidentByEventId(ctx context.Context, eventId string) ApiIncidentsServiceAcknowledgeIncidentByEventIdRequest {
	return ApiIncidentsServiceAcknowledgeIncidentByEventIdRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return AcknowledgeIncidentByEventIdResponse
func (a *IncidentsServiceAPIService) IncidentsServiceAcknowledgeIncidentByEventIdExecute(r ApiIncidentsServiceAcknowledgeIncidentByEventIdRequest) (*AcknowledgeIncidentByEventIdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AcknowledgeIncidentByEventIdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceAcknowledgeIncidentByEventId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/events/{event_id}/acknowledge"
	localVarPath = strings.Replace(localVarPath, "{"+"event_id"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceAcknowledgeIncidentsRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	incidentIds *[]string
}

func (r ApiIncidentsServiceAcknowledgeIncidentsRequest) IncidentIds(incidentIds []string) ApiIncidentsServiceAcknowledgeIncidentsRequest {
	r.incidentIds = &incidentIds
	return r
}

func (r ApiIncidentsServiceAcknowledgeIncidentsRequest) Execute() (*AcknowledgeIncidentsResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceAcknowledgeIncidentsExecute(r)
}

/*
IncidentsServiceAcknowledgeIncidents Acknowledge incidents

Mark one or more incidents as acknowledged.

Requires the following permissions:
- `incidents:acknowledge`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIncidentsServiceAcknowledgeIncidentsRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceAcknowledgeIncidents(ctx context.Context) ApiIncidentsServiceAcknowledgeIncidentsRequest {
	return ApiIncidentsServiceAcknowledgeIncidentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AcknowledgeIncidentsResponse
func (a *IncidentsServiceAPIService) IncidentsServiceAcknowledgeIncidentsExecute(r ApiIncidentsServiceAcknowledgeIncidentsRequest) (*AcknowledgeIncidentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AcknowledgeIncidentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceAcknowledgeIncidents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/acknowledge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.incidentIds != nil {
		t := *r.incidentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "incident_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "incident_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceAssignIncidentsRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	incidentIds *[]string
	assignedTo *UserDetails
}

func (r ApiIncidentsServiceAssignIncidentsRequest) IncidentIds(incidentIds []string) ApiIncidentsServiceAssignIncidentsRequest {
	r.incidentIds = &incidentIds
	return r
}

func (r ApiIncidentsServiceAssignIncidentsRequest) AssignedTo(assignedTo UserDetails) ApiIncidentsServiceAssignIncidentsRequest {
	r.assignedTo = &assignedTo
	return r
}

func (r ApiIncidentsServiceAssignIncidentsRequest) Execute() (*AssignIncidentsResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceAssignIncidentsExecute(r)
}

/*
IncidentsServiceAssignIncidents Assign incidents to a user

Assign one or more incidents to a specific user.

Requires the following permissions:
- `incidents:assign`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIncidentsServiceAssignIncidentsRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceAssignIncidents(ctx context.Context) ApiIncidentsServiceAssignIncidentsRequest {
	return ApiIncidentsServiceAssignIncidentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssignIncidentsResponse
func (a *IncidentsServiceAPIService) IncidentsServiceAssignIncidentsExecute(r ApiIncidentsServiceAssignIncidentsRequest) (*AssignIncidentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssignIncidentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceAssignIncidents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/by-user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.incidentIds != nil {
		t := *r.incidentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "incident_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "incident_ids", t, "form", "multi")
		}
	}
	if r.assignedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_to", r.assignedTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceBatchGetIncidentRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	ids *[]string
}

func (r ApiIncidentsServiceBatchGetIncidentRequest) Ids(ids []string) ApiIncidentsServiceBatchGetIncidentRequest {
	r.ids = &ids
	return r
}

func (r ApiIncidentsServiceBatchGetIncidentRequest) Execute() (*BatchGetIncidentResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceBatchGetIncidentExecute(r)
}

/*
IncidentsServiceBatchGetIncident Get multiple incidents by IDs

Retrieve multiple incidents by their IDs in a single request.

Requires the following permissions:
- `incidents:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIncidentsServiceBatchGetIncidentRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceBatchGetIncident(ctx context.Context) ApiIncidentsServiceBatchGetIncidentRequest {
	return ApiIncidentsServiceBatchGetIncidentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchGetIncidentResponse
func (a *IncidentsServiceAPIService) IncidentsServiceBatchGetIncidentExecute(r ApiIncidentsServiceBatchGetIncidentRequest) (*BatchGetIncidentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchGetIncidentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceBatchGetIncident")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceCloseIncidentsRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	incidentIds *[]string
}

func (r ApiIncidentsServiceCloseIncidentsRequest) IncidentIds(incidentIds []string) ApiIncidentsServiceCloseIncidentsRequest {
	r.incidentIds = &incidentIds
	return r
}

func (r ApiIncidentsServiceCloseIncidentsRequest) Execute() (*CloseIncidentsResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceCloseIncidentsExecute(r)
}

/*
IncidentsServiceCloseIncidents Close incidents

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIncidentsServiceCloseIncidentsRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceCloseIncidents(ctx context.Context) ApiIncidentsServiceCloseIncidentsRequest {
	return ApiIncidentsServiceCloseIncidentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CloseIncidentsResponse
func (a *IncidentsServiceAPIService) IncidentsServiceCloseIncidentsExecute(r ApiIncidentsServiceCloseIncidentsRequest) (*CloseIncidentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CloseIncidentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceCloseIncidents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/close"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.incidentIds != nil {
		t := *r.incidentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "incident_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "incident_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceGetFilterValuesRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	filter *IncidentQueryFilter
}

func (r ApiIncidentsServiceGetFilterValuesRequest) Filter(filter IncidentQueryFilter) ApiIncidentsServiceGetFilterValuesRequest {
	r.filter = &filter
	return r
}

func (r ApiIncidentsServiceGetFilterValuesRequest) Execute() (*GetFilterValuesResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceGetFilterValuesExecute(r)
}

/*
IncidentsServiceGetFilterValues Get available filter values

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIncidentsServiceGetFilterValuesRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceGetFilterValues(ctx context.Context) ApiIncidentsServiceGetFilterValuesRequest {
	return ApiIncidentsServiceGetFilterValuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFilterValuesResponse
func (a *IncidentsServiceAPIService) IncidentsServiceGetFilterValuesExecute(r ApiIncidentsServiceGetFilterValuesRequest) (*GetFilterValuesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFilterValuesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceGetFilterValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/filter-values"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceGetIncidentRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	id string
}

func (r ApiIncidentsServiceGetIncidentRequest) Execute() (*GetIncidentResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceGetIncidentExecute(r)
}

/*
IncidentsServiceGetIncident Get incident by ID

Retrieve detailed information about a single incident by its unique identifier.

Requires the following permissions:
- `incidents:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIncidentsServiceGetIncidentRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceGetIncident(ctx context.Context, id string) ApiIncidentsServiceGetIncidentRequest {
	return ApiIncidentsServiceGetIncidentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetIncidentResponse
func (a *IncidentsServiceAPIService) IncidentsServiceGetIncidentExecute(r ApiIncidentsServiceGetIncidentRequest) (*GetIncidentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIncidentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceGetIncident")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceGetIncidentByEventIdRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	eventId string
}

func (r ApiIncidentsServiceGetIncidentByEventIdRequest) Execute() (*GetIncidentByEventIdResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceGetIncidentByEventIdExecute(r)
}

/*
IncidentsServiceGetIncidentByEventId Get incident by event ID

Retrieve detailed information about a single incident by related alert event id.

Requires the following permissions:
- `incidents:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId
 @return ApiIncidentsServiceGetIncidentByEventIdRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceGetIncidentByEventId(ctx context.Context, eventId string) ApiIncidentsServiceGetIncidentByEventIdRequest {
	return ApiIncidentsServiceGetIncidentByEventIdRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return GetIncidentByEventIdResponse
func (a *IncidentsServiceAPIService) IncidentsServiceGetIncidentByEventIdExecute(r ApiIncidentsServiceGetIncidentByEventIdRequest) (*GetIncidentByEventIdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIncidentByEventIdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceGetIncidentByEventId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/events/{event_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"event_id"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceGetIncidentEventsRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	incidentId string
}

func (r ApiIncidentsServiceGetIncidentEventsRequest) Execute() (*GetIncidentEventsResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceGetIncidentEventsExecute(r)
}

/*
IncidentsServiceGetIncidentEvents Get incident events

Retrieve a chronological list of all events associated with a specific incident. Includes state changes, assignments, acknowledgments, and resolutions.

Requires the following permissions:
- `incidents:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param incidentId
 @return ApiIncidentsServiceGetIncidentEventsRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceGetIncidentEvents(ctx context.Context, incidentId string) ApiIncidentsServiceGetIncidentEventsRequest {
	return ApiIncidentsServiceGetIncidentEventsRequest{
		ApiService: a,
		ctx: ctx,
		incidentId: incidentId,
	}
}

// Execute executes the request
//  @return GetIncidentEventsResponse
func (a *IncidentsServiceAPIService) IncidentsServiceGetIncidentEventsExecute(r ApiIncidentsServiceGetIncidentEventsRequest) (*GetIncidentEventsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIncidentEventsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceGetIncidentEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/{incident_id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"incident_id"+"}", url.PathEscape(parameterValueToString(r.incidentId, "incidentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceListIncidentAggregationsRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	filter *IncidentQueryFilter
	groupBys *[]IncidentsServiceListIncidentAggregationsGroupBysParameterInner
	pagination *PaginationRequest
}

func (r ApiIncidentsServiceListIncidentAggregationsRequest) Filter(filter IncidentQueryFilter) ApiIncidentsServiceListIncidentAggregationsRequest {
	r.filter = &filter
	return r
}

func (r ApiIncidentsServiceListIncidentAggregationsRequest) GroupBys(groupBys []IncidentsServiceListIncidentAggregationsGroupBysParameterInner) ApiIncidentsServiceListIncidentAggregationsRequest {
	r.groupBys = &groupBys
	return r
}

func (r ApiIncidentsServiceListIncidentAggregationsRequest) Pagination(pagination PaginationRequest) ApiIncidentsServiceListIncidentAggregationsRequest {
	r.pagination = &pagination
	return r
}

func (r ApiIncidentsServiceListIncidentAggregationsRequest) Execute() (*ListIncidentAggregationsResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceListIncidentAggregationsExecute(r)
}

/*
IncidentsServiceListIncidentAggregations Get incident aggregations

Retrieve aggregated incident data with support for grouping and filtering.

Requires the following permissions:
- `incidents:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIncidentsServiceListIncidentAggregationsRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceListIncidentAggregations(ctx context.Context) ApiIncidentsServiceListIncidentAggregationsRequest {
	return ApiIncidentsServiceListIncidentAggregationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListIncidentAggregationsResponse
func (a *IncidentsServiceAPIService) IncidentsServiceListIncidentAggregationsExecute(r ApiIncidentsServiceListIncidentAggregationsRequest) (*ListIncidentAggregationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIncidentAggregationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceListIncidentAggregations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/aggregations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.groupBys != nil {
		t := *r.groupBys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_bys", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_bys", t, "form", "multi")
		}
	}
	if r.pagination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagination", r.pagination, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceListIncidentEventsRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	filter *IncidentEventQueryFilter
	pagination *PaginationRequest
	orderBy *ListIncidentEventsOrderByRequest
}

func (r ApiIncidentsServiceListIncidentEventsRequest) Filter(filter IncidentEventQueryFilter) ApiIncidentsServiceListIncidentEventsRequest {
	r.filter = &filter
	return r
}

func (r ApiIncidentsServiceListIncidentEventsRequest) Pagination(pagination PaginationRequest) ApiIncidentsServiceListIncidentEventsRequest {
	r.pagination = &pagination
	return r
}

func (r ApiIncidentsServiceListIncidentEventsRequest) OrderBy(orderBy ListIncidentEventsOrderByRequest) ApiIncidentsServiceListIncidentEventsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiIncidentsServiceListIncidentEventsRequest) Execute() (*ListIncidentEventsResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceListIncidentEventsExecute(r)
}

/*
IncidentsServiceListIncidentEvents List incident events with filters

List incident events with support for filtering, pagination, and ordering.

Requires the following permissions:
- `incidents:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIncidentsServiceListIncidentEventsRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceListIncidentEvents(ctx context.Context) ApiIncidentsServiceListIncidentEventsRequest {
	return ApiIncidentsServiceListIncidentEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListIncidentEventsResponse
func (a *IncidentsServiceAPIService) IncidentsServiceListIncidentEventsExecute(r ApiIncidentsServiceListIncidentEventsRequest) (*ListIncidentEventsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIncidentEventsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceListIncidentEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.pagination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagination", r.pagination, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceListIncidentEventsFilterValuesRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	filter *IncidentEventQueryFilter
}

func (r ApiIncidentsServiceListIncidentEventsFilterValuesRequest) Filter(filter IncidentEventQueryFilter) ApiIncidentsServiceListIncidentEventsFilterValuesRequest {
	r.filter = &filter
	return r
}

func (r ApiIncidentsServiceListIncidentEventsFilterValuesRequest) Execute() (*ListIncidentEventsFilterValuesResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceListIncidentEventsFilterValuesExecute(r)
}

/*
IncidentsServiceListIncidentEventsFilterValues Get available incident event filter values

No description available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIncidentsServiceListIncidentEventsFilterValuesRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceListIncidentEventsFilterValues(ctx context.Context) ApiIncidentsServiceListIncidentEventsFilterValuesRequest {
	return ApiIncidentsServiceListIncidentEventsFilterValuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListIncidentEventsFilterValuesResponse
func (a *IncidentsServiceAPIService) IncidentsServiceListIncidentEventsFilterValuesExecute(r ApiIncidentsServiceListIncidentEventsFilterValuesRequest) (*ListIncidentEventsFilterValuesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIncidentEventsFilterValuesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceListIncidentEventsFilterValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/events/filter-values"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceListIncidentEventsTotalCountRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	filter *IncidentEventQueryFilter
}

func (r ApiIncidentsServiceListIncidentEventsTotalCountRequest) Filter(filter IncidentEventQueryFilter) ApiIncidentsServiceListIncidentEventsTotalCountRequest {
	r.filter = &filter
	return r
}

func (r ApiIncidentsServiceListIncidentEventsTotalCountRequest) Execute() (*ListIncidentEventsTotalCountResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceListIncidentEventsTotalCountExecute(r)
}

/*
IncidentsServiceListIncidentEventsTotalCount Get total count of incident events

Retrieve the total count of incident events matching a filter.

Requires the following permissions:
- `incidents:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIncidentsServiceListIncidentEventsTotalCountRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceListIncidentEventsTotalCount(ctx context.Context) ApiIncidentsServiceListIncidentEventsTotalCountRequest {
	return ApiIncidentsServiceListIncidentEventsTotalCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListIncidentEventsTotalCountResponse
func (a *IncidentsServiceAPIService) IncidentsServiceListIncidentEventsTotalCountExecute(r ApiIncidentsServiceListIncidentEventsTotalCountRequest) (*ListIncidentEventsTotalCountResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIncidentEventsTotalCountResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceListIncidentEventsTotalCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/events/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceListIncidentsRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	filter *IncidentQueryFilter
	pagination *PaginationRequest
	orderBys *[]IncidentsServiceListIncidentsOrderBysParameterInner
}

func (r ApiIncidentsServiceListIncidentsRequest) Filter(filter IncidentQueryFilter) ApiIncidentsServiceListIncidentsRequest {
	r.filter = &filter
	return r
}

func (r ApiIncidentsServiceListIncidentsRequest) Pagination(pagination PaginationRequest) ApiIncidentsServiceListIncidentsRequest {
	r.pagination = &pagination
	return r
}

func (r ApiIncidentsServiceListIncidentsRequest) OrderBys(orderBys []IncidentsServiceListIncidentsOrderBysParameterInner) ApiIncidentsServiceListIncidentsRequest {
	r.orderBys = &orderBys
	return r
}

func (r ApiIncidentsServiceListIncidentsRequest) Execute() (*ListIncidentsResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceListIncidentsExecute(r)
}

/*
IncidentsServiceListIncidents List incidents with filters

Lists all available incidents based on specified filters and order. The list is ordered in an unspecified direction and sorted by creation time.

Requires the following permissions:
- `incidents:read`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIncidentsServiceListIncidentsRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceListIncidents(ctx context.Context) ApiIncidentsServiceListIncidentsRequest {
	return ApiIncidentsServiceListIncidentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListIncidentsResponse
func (a *IncidentsServiceAPIService) IncidentsServiceListIncidentsExecute(r ApiIncidentsServiceListIncidentsRequest) (*ListIncidentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIncidentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceListIncidents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.pagination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagination", r.pagination, "form", "")
	}
	if r.orderBys != nil {
		t := *r.orderBys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "order_bys", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "order_bys", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceResolveIncidentByEventIdRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	eventId string
}

func (r ApiIncidentsServiceResolveIncidentByEventIdRequest) Execute() (*ResolveIncidentByEventIdResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceResolveIncidentByEventIdExecute(r)
}

/*
IncidentsServiceResolveIncidentByEventId Resolve incident by event id

Mark incident as resolved by event id.

Requires the following permissions:
- `incidents:close`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId
 @return ApiIncidentsServiceResolveIncidentByEventIdRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceResolveIncidentByEventId(ctx context.Context, eventId string) ApiIncidentsServiceResolveIncidentByEventIdRequest {
	return ApiIncidentsServiceResolveIncidentByEventIdRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return ResolveIncidentByEventIdResponse
func (a *IncidentsServiceAPIService) IncidentsServiceResolveIncidentByEventIdExecute(r ApiIncidentsServiceResolveIncidentByEventIdRequest) (*ResolveIncidentByEventIdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResolveIncidentByEventIdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceResolveIncidentByEventId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/events/{event_id}/resolve"
	localVarPath = strings.Replace(localVarPath, "{"+"event_id"+"}", url.PathEscape(parameterValueToString(r.eventId, "eventId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceResolveIncidentsRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	incidentIds *[]string
}

func (r ApiIncidentsServiceResolveIncidentsRequest) IncidentIds(incidentIds []string) ApiIncidentsServiceResolveIncidentsRequest {
	r.incidentIds = &incidentIds
	return r
}

func (r ApiIncidentsServiceResolveIncidentsRequest) Execute() (*ResolveIncidentsResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceResolveIncidentsExecute(r)
}

/*
IncidentsServiceResolveIncidents Resolve incidents

Mark one or more incidents as resolved.

Requires the following permissions:
- `incidents:close`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIncidentsServiceResolveIncidentsRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceResolveIncidents(ctx context.Context) ApiIncidentsServiceResolveIncidentsRequest {
	return ApiIncidentsServiceResolveIncidentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResolveIncidentsResponse
func (a *IncidentsServiceAPIService) IncidentsServiceResolveIncidentsExecute(r ApiIncidentsServiceResolveIncidentsRequest) (*ResolveIncidentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResolveIncidentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceResolveIncidents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/resolve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.incidentIds != nil {
		t := *r.incidentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "incident_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "incident_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIncidentsServiceUnassignIncidentsRequest struct {
	ctx context.Context
	ApiService *IncidentsServiceAPIService
	incidentIds *[]string
}

func (r ApiIncidentsServiceUnassignIncidentsRequest) IncidentIds(incidentIds []string) ApiIncidentsServiceUnassignIncidentsRequest {
	r.incidentIds = &incidentIds
	return r
}

func (r ApiIncidentsServiceUnassignIncidentsRequest) Execute() (*UnassignIncidentsResponse, *http.Response, error) {
	return r.ApiService.IncidentsServiceUnassignIncidentsExecute(r)
}

/*
IncidentsServiceUnassignIncidents Remove incident user assignments

Remove user assignments from one or more incidents.

Requires the following permissions:
- `incidents:assign`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIncidentsServiceUnassignIncidentsRequest
*/
func (a *IncidentsServiceAPIService) IncidentsServiceUnassignIncidents(ctx context.Context) ApiIncidentsServiceUnassignIncidentsRequest {
	return ApiIncidentsServiceUnassignIncidentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnassignIncidentsResponse
func (a *IncidentsServiceAPIService) IncidentsServiceUnassignIncidentsExecute(r ApiIncidentsServiceUnassignIncidentsRequest) (*UnassignIncidentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnassignIncidentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IncidentsServiceAPIService.IncidentsServiceUnassignIncidents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/incidents/incidents/v1/by-user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.incidentIds != nil {
		t := *r.incidentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "incident_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "incident_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
