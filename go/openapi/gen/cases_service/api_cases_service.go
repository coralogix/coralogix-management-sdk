/*


No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cases_service

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// CasesServiceAPIService CasesServiceAPI service
type CasesServiceAPIService service

type ApiCasesServiceAcknowledgeCaseRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	id string
	acknowledgeCaseRequest *AcknowledgeCaseRequest
}

func (r ApiCasesServiceAcknowledgeCaseRequest) AcknowledgeCaseRequest(acknowledgeCaseRequest AcknowledgeCaseRequest) ApiCasesServiceAcknowledgeCaseRequest {
	r.acknowledgeCaseRequest = &acknowledgeCaseRequest
	return r
}

func (r ApiCasesServiceAcknowledgeCaseRequest) Execute() (*AcknowledgeCaseResponse, *http.Response, error) {
	return r.ApiService.CasesServiceAcknowledgeCaseExecute(r)
}

/*
CasesServiceAcknowledgeCase Acknowledge a case

Mark the case as acknowledged by a user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCasesServiceAcknowledgeCaseRequest
*/
func (a *CasesServiceAPIService) CasesServiceAcknowledgeCase(ctx context.Context, id string) ApiCasesServiceAcknowledgeCaseRequest {
	return ApiCasesServiceAcknowledgeCaseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AcknowledgeCaseResponse
func (a *CasesServiceAPIService) CasesServiceAcknowledgeCaseExecute(r ApiCasesServiceAcknowledgeCaseRequest) (*AcknowledgeCaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AcknowledgeCaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceAcknowledgeCase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1/{id}:acknowledge"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.acknowledgeCaseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceAssignCaseRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	id string
	assignCaseRequest *AssignCaseRequest
}

func (r ApiCasesServiceAssignCaseRequest) AssignCaseRequest(assignCaseRequest AssignCaseRequest) ApiCasesServiceAssignCaseRequest {
	r.assignCaseRequest = &assignCaseRequest
	return r
}

func (r ApiCasesServiceAssignCaseRequest) Execute() (*AssignCaseResponse, *http.Response, error) {
	return r.ApiService.CasesServiceAssignCaseExecute(r)
}

/*
CasesServiceAssignCase Assign a case to a user

Assign a case to a specific user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCasesServiceAssignCaseRequest
*/
func (a *CasesServiceAPIService) CasesServiceAssignCase(ctx context.Context, id string) ApiCasesServiceAssignCaseRequest {
	return ApiCasesServiceAssignCaseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AssignCaseResponse
func (a *CasesServiceAPIService) CasesServiceAssignCaseExecute(r ApiCasesServiceAssignCaseRequest) (*AssignCaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssignCaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceAssignCase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1/{id}:assign"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assignCaseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceBulkAcknowledgeRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	bulkAcknowledgeRequest *BulkAcknowledgeRequest
}

func (r ApiCasesServiceBulkAcknowledgeRequest) BulkAcknowledgeRequest(bulkAcknowledgeRequest BulkAcknowledgeRequest) ApiCasesServiceBulkAcknowledgeRequest {
	r.bulkAcknowledgeRequest = &bulkAcknowledgeRequest
	return r
}

func (r ApiCasesServiceBulkAcknowledgeRequest) Execute() (*BulkAcknowledgeResponse, *http.Response, error) {
	return r.ApiService.CasesServiceBulkAcknowledgeExecute(r)
}

/*
CasesServiceBulkAcknowledge Acknowledge multiple cases

Mark multiple cases as acknowledged in a single operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCasesServiceBulkAcknowledgeRequest
*/
func (a *CasesServiceAPIService) CasesServiceBulkAcknowledge(ctx context.Context) ApiCasesServiceBulkAcknowledgeRequest {
	return ApiCasesServiceBulkAcknowledgeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkAcknowledgeResponse
func (a *CasesServiceAPIService) CasesServiceBulkAcknowledgeExecute(r ApiCasesServiceBulkAcknowledgeRequest) (*BulkAcknowledgeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkAcknowledgeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceBulkAcknowledge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1:bulkAcknowledge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkAcknowledgeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceBulkAssignRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	bulkAssignRequest *BulkAssignRequest
}

func (r ApiCasesServiceBulkAssignRequest) BulkAssignRequest(bulkAssignRequest BulkAssignRequest) ApiCasesServiceBulkAssignRequest {
	r.bulkAssignRequest = &bulkAssignRequest
	return r
}

func (r ApiCasesServiceBulkAssignRequest) Execute() (*BulkAssignResponse, *http.Response, error) {
	return r.ApiService.CasesServiceBulkAssignExecute(r)
}

/*
CasesServiceBulkAssign Assign multiple cases to a user

Assign multiple cases to a specific user in a single operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCasesServiceBulkAssignRequest
*/
func (a *CasesServiceAPIService) CasesServiceBulkAssign(ctx context.Context) ApiCasesServiceBulkAssignRequest {
	return ApiCasesServiceBulkAssignRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkAssignResponse
func (a *CasesServiceAPIService) CasesServiceBulkAssignExecute(r ApiCasesServiceBulkAssignRequest) (*BulkAssignResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkAssignResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceBulkAssign")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1:bulkAssign"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkAssignRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceBulkClearPriorityOverrideRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	bulkClearPriorityOverrideRequest *BulkClearPriorityOverrideRequest
}

func (r ApiCasesServiceBulkClearPriorityOverrideRequest) BulkClearPriorityOverrideRequest(bulkClearPriorityOverrideRequest BulkClearPriorityOverrideRequest) ApiCasesServiceBulkClearPriorityOverrideRequest {
	r.bulkClearPriorityOverrideRequest = &bulkClearPriorityOverrideRequest
	return r
}

func (r ApiCasesServiceBulkClearPriorityOverrideRequest) Execute() (*BulkClearPriorityOverrideResponse, *http.Response, error) {
	return r.ApiService.CasesServiceBulkClearPriorityOverrideExecute(r)
}

/*
CasesServiceBulkClearPriorityOverride Remove priority override from multiple cases

Remove previously set priority overrides from multiple cases in a single operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCasesServiceBulkClearPriorityOverrideRequest
*/
func (a *CasesServiceAPIService) CasesServiceBulkClearPriorityOverride(ctx context.Context) ApiCasesServiceBulkClearPriorityOverrideRequest {
	return ApiCasesServiceBulkClearPriorityOverrideRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkClearPriorityOverrideResponse
func (a *CasesServiceAPIService) CasesServiceBulkClearPriorityOverrideExecute(r ApiCasesServiceBulkClearPriorityOverrideRequest) (*BulkClearPriorityOverrideResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkClearPriorityOverrideResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceBulkClearPriorityOverride")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1:bulkClearPriorityOverride"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkClearPriorityOverrideRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceBulkCloseRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	bulkCloseRequest *BulkCloseRequest
}

func (r ApiCasesServiceBulkCloseRequest) BulkCloseRequest(bulkCloseRequest BulkCloseRequest) ApiCasesServiceBulkCloseRequest {
	r.bulkCloseRequest = &bulkCloseRequest
	return r
}

func (r ApiCasesServiceBulkCloseRequest) Execute() (*BulkCloseResponse, *http.Response, error) {
	return r.ApiService.CasesServiceBulkCloseExecute(r)
}

/*
CasesServiceBulkClose Close multiple cases

Close multiple cases in a single operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCasesServiceBulkCloseRequest
*/
func (a *CasesServiceAPIService) CasesServiceBulkClose(ctx context.Context) ApiCasesServiceBulkCloseRequest {
	return ApiCasesServiceBulkCloseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkCloseResponse
func (a *CasesServiceAPIService) CasesServiceBulkCloseExecute(r ApiCasesServiceBulkCloseRequest) (*BulkCloseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkCloseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceBulkClose")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1:bulkClose"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkCloseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceBulkResolveRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	bulkResolveRequest *BulkResolveRequest
}

func (r ApiCasesServiceBulkResolveRequest) BulkResolveRequest(bulkResolveRequest BulkResolveRequest) ApiCasesServiceBulkResolveRequest {
	r.bulkResolveRequest = &bulkResolveRequest
	return r
}

func (r ApiCasesServiceBulkResolveRequest) Execute() (*BulkResolveResponse, *http.Response, error) {
	return r.ApiService.CasesServiceBulkResolveExecute(r)
}

/*
CasesServiceBulkResolve Resolve multiple cases

Resolve multiple cases in a single operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCasesServiceBulkResolveRequest
*/
func (a *CasesServiceAPIService) CasesServiceBulkResolve(ctx context.Context) ApiCasesServiceBulkResolveRequest {
	return ApiCasesServiceBulkResolveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkResolveResponse
func (a *CasesServiceAPIService) CasesServiceBulkResolveExecute(r ApiCasesServiceBulkResolveRequest) (*BulkResolveResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkResolveResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceBulkResolve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1:bulkResolve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkResolveRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceBulkSetPriorityOverrideRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	bulkOverridePriorityRequest *BulkOverridePriorityRequest
}

func (r ApiCasesServiceBulkSetPriorityOverrideRequest) BulkOverridePriorityRequest(bulkOverridePriorityRequest BulkOverridePriorityRequest) ApiCasesServiceBulkSetPriorityOverrideRequest {
	r.bulkOverridePriorityRequest = &bulkOverridePriorityRequest
	return r
}

func (r ApiCasesServiceBulkSetPriorityOverrideRequest) Execute() (*BulkSetPriorityOverrideResponse, *http.Response, error) {
	return r.ApiService.CasesServiceBulkSetPriorityOverrideExecute(r)
}

/*
CasesServiceBulkSetPriorityOverride Override priority for multiple cases

Override the priority with for multiple cases in a single operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCasesServiceBulkSetPriorityOverrideRequest
*/
func (a *CasesServiceAPIService) CasesServiceBulkSetPriorityOverride(ctx context.Context) ApiCasesServiceBulkSetPriorityOverrideRequest {
	return ApiCasesServiceBulkSetPriorityOverrideRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkSetPriorityOverrideResponse
func (a *CasesServiceAPIService) CasesServiceBulkSetPriorityOverrideExecute(r ApiCasesServiceBulkSetPriorityOverrideRequest) (*BulkSetPriorityOverrideResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkSetPriorityOverrideResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceBulkSetPriorityOverride")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1:bulkSetPriorityOverride"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOverridePriorityRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceBulkUnassignRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	bulkUnassignRequest *BulkUnassignRequest
}

func (r ApiCasesServiceBulkUnassignRequest) BulkUnassignRequest(bulkUnassignRequest BulkUnassignRequest) ApiCasesServiceBulkUnassignRequest {
	r.bulkUnassignRequest = &bulkUnassignRequest
	return r
}

func (r ApiCasesServiceBulkUnassignRequest) Execute() (*BulkUnassignResponse, *http.Response, error) {
	return r.ApiService.CasesServiceBulkUnassignExecute(r)
}

/*
CasesServiceBulkUnassign Remove assignment from multiple cases

Remove the current assignee from multiple cases in a single operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCasesServiceBulkUnassignRequest
*/
func (a *CasesServiceAPIService) CasesServiceBulkUnassign(ctx context.Context) ApiCasesServiceBulkUnassignRequest {
	return ApiCasesServiceBulkUnassignRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkUnassignResponse
func (a *CasesServiceAPIService) CasesServiceBulkUnassignExecute(r ApiCasesServiceBulkUnassignRequest) (*BulkUnassignResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkUnassignResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceBulkUnassign")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1:bulkUnassign"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkUnassignRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceClearPriorityOverrideRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	id string
}

func (r ApiCasesServiceClearPriorityOverrideRequest) Execute() (*ClearPriorityOverrideResponse, *http.Response, error) {
	return r.ApiService.CasesServiceClearPriorityOverrideExecute(r)
}

/*
CasesServiceClearPriorityOverride Remove priority override

Remove a previously set priority override for a case.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCasesServiceClearPriorityOverrideRequest
*/
func (a *CasesServiceAPIService) CasesServiceClearPriorityOverride(ctx context.Context, id string) ApiCasesServiceClearPriorityOverrideRequest {
	return ApiCasesServiceClearPriorityOverrideRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ClearPriorityOverrideResponse
func (a *CasesServiceAPIService) CasesServiceClearPriorityOverrideExecute(r ApiCasesServiceClearPriorityOverrideRequest) (*ClearPriorityOverrideResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClearPriorityOverrideResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceClearPriorityOverride")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1/{id}:clearPriorityOverride"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceCloseCaseRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	id string
}

func (r ApiCasesServiceCloseCaseRequest) Execute() (*CloseCaseResponse, *http.Response, error) {
	return r.ApiService.CasesServiceCloseCaseExecute(r)
}

/*
CasesServiceCloseCase Close a case

Close a case that no longer requires action.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCasesServiceCloseCaseRequest
*/
func (a *CasesServiceAPIService) CasesServiceCloseCase(ctx context.Context, id string) ApiCasesServiceCloseCaseRequest {
	return ApiCasesServiceCloseCaseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CloseCaseResponse
func (a *CasesServiceAPIService) CasesServiceCloseCaseExecute(r ApiCasesServiceCloseCaseRequest) (*CloseCaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CloseCaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceCloseCase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1/{id}:close"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceGetCaseRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	id string
}

func (r ApiCasesServiceGetCaseRequest) Execute() (*GetCaseResponse, *http.Response, error) {
	return r.ApiService.CasesServiceGetCaseExecute(r)
}

/*
CasesServiceGetCase Get case by ID

Retrieve detailed information about a single case by its unique identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCasesServiceGetCaseRequest
*/
func (a *CasesServiceAPIService) CasesServiceGetCase(ctx context.Context, id string) ApiCasesServiceGetCaseRequest {
	return ApiCasesServiceGetCaseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetCaseResponse
func (a *CasesServiceAPIService) CasesServiceGetCaseExecute(r ApiCasesServiceGetCaseRequest) (*GetCaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceGetCase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceGetCaseExternalReferencesRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	caseId string
}

func (r ApiCasesServiceGetCaseExternalReferencesRequest) Execute() (*GetCaseExternalReferencesResponse, *http.Response, error) {
	return r.ApiService.CasesServiceGetCaseExternalReferencesExecute(r)
}

/*
CasesServiceGetCaseExternalReferences Get external references for a case

Retrieve all external references that link a case to external systems such as ServiceNow. Returns the complete list of external references associated with the specified case.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param caseId
 @return ApiCasesServiceGetCaseExternalReferencesRequest
*/
func (a *CasesServiceAPIService) CasesServiceGetCaseExternalReferences(ctx context.Context, caseId string) ApiCasesServiceGetCaseExternalReferencesRequest {
	return ApiCasesServiceGetCaseExternalReferencesRequest{
		ApiService: a,
		ctx: ctx,
		caseId: caseId,
	}
}

// Execute executes the request
//  @return GetCaseExternalReferencesResponse
func (a *CasesServiceAPIService) CasesServiceGetCaseExternalReferencesExecute(r ApiCasesServiceGetCaseExternalReferencesRequest) (*GetCaseExternalReferencesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCaseExternalReferencesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceGetCaseExternalReferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1/{case_id}/external-references"
	localVarPath = strings.Replace(localVarPath, "{"+"case_id"+"}", url.PathEscape(parameterValueToString(r.caseId, "caseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceGetFilterValuesRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	getCaseFilterValuesRequest *GetCaseFilterValuesRequest
}

func (r ApiCasesServiceGetFilterValuesRequest) GetCaseFilterValuesRequest(getCaseFilterValuesRequest GetCaseFilterValuesRequest) ApiCasesServiceGetFilterValuesRequest {
	r.getCaseFilterValuesRequest = &getCaseFilterValuesRequest
	return r
}

func (r ApiCasesServiceGetFilterValuesRequest) Execute() (*CasesV1GetFilterValuesResponse, *http.Response, error) {
	return r.ApiService.CasesServiceGetFilterValuesExecute(r)
}

/*
CasesServiceGetFilterValues Get available filter values

Retrieve available filter and aggregation values for cases.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCasesServiceGetFilterValuesRequest
*/
func (a *CasesServiceAPIService) CasesServiceGetFilterValues(ctx context.Context) ApiCasesServiceGetFilterValuesRequest {
	return ApiCasesServiceGetFilterValuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CasesV1GetFilterValuesResponse
func (a *CasesServiceAPIService) CasesServiceGetFilterValuesExecute(r ApiCasesServiceGetFilterValuesRequest) (*CasesV1GetFilterValuesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CasesV1GetFilterValuesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceGetFilterValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1:get-filter-values"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getCaseFilterValuesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceGetGroupingKeysRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
}

func (r ApiCasesServiceGetGroupingKeysRequest) Execute() (*GetGroupingKeysResponse, *http.Response, error) {
	return r.ApiService.CasesServiceGetGroupingKeysExecute(r)
}

/*
CasesServiceGetGroupingKeys Get available grouping keys

Retrieve all available grouping keys that can be used for organizing and filtering Cases.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCasesServiceGetGroupingKeysRequest
*/
func (a *CasesServiceAPIService) CasesServiceGetGroupingKeys(ctx context.Context) ApiCasesServiceGetGroupingKeysRequest {
	return ApiCasesServiceGetGroupingKeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetGroupingKeysResponse
func (a *CasesServiceAPIService) CasesServiceGetGroupingKeysExecute(r ApiCasesServiceGetGroupingKeysRequest) (*GetGroupingKeysResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetGroupingKeysResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceGetGroupingKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1:groupingKeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceListCasesRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	listCasesRequest *ListCasesRequest
}

func (r ApiCasesServiceListCasesRequest) ListCasesRequest(listCasesRequest ListCasesRequest) ApiCasesServiceListCasesRequest {
	r.listCasesRequest = &listCasesRequest
	return r
}

func (r ApiCasesServiceListCasesRequest) Execute() (*ListCasesResponse, *http.Response, error) {
	return r.ApiService.CasesServiceListCasesExecute(r)
}

/*
CasesServiceListCases List cases with filters

List cases using filters, pagination and custom ordering.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCasesServiceListCasesRequest
*/
func (a *CasesServiceAPIService) CasesServiceListCases(ctx context.Context) ApiCasesServiceListCasesRequest {
	return ApiCasesServiceListCasesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListCasesResponse
func (a *CasesServiceAPIService) CasesServiceListCasesExecute(r ApiCasesServiceListCasesRequest) (*ListCasesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListCasesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceListCases")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listCasesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceResolveCaseRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	id string
	reason *string
}

func (r ApiCasesServiceResolveCaseRequest) Reason(reason string) ApiCasesServiceResolveCaseRequest {
	r.reason = &reason
	return r
}

func (r ApiCasesServiceResolveCaseRequest) Execute() (*ResolveCaseResponse, *http.Response, error) {
	return r.ApiService.CasesServiceResolveCaseExecute(r)
}

/*
CasesServiceResolveCase Resolve a case

Mark a case as resolved.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCasesServiceResolveCaseRequest
*/
func (a *CasesServiceAPIService) CasesServiceResolveCase(ctx context.Context, id string) ApiCasesServiceResolveCaseRequest {
	return ApiCasesServiceResolveCaseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResolveCaseResponse
func (a *CasesServiceAPIService) CasesServiceResolveCaseExecute(r ApiCasesServiceResolveCaseRequest) (*ResolveCaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResolveCaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceResolveCase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1/{id}:resolve"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.reason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reason", r.reason, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceSetPriorityOverrideRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	id string
	setPriorityOverrideRequest *SetPriorityOverrideRequest
}

func (r ApiCasesServiceSetPriorityOverrideRequest) SetPriorityOverrideRequest(setPriorityOverrideRequest SetPriorityOverrideRequest) ApiCasesServiceSetPriorityOverrideRequest {
	r.setPriorityOverrideRequest = &setPriorityOverrideRequest
	return r
}

func (r ApiCasesServiceSetPriorityOverrideRequest) Execute() (*SetPriorityOverrideResponse, *http.Response, error) {
	return r.ApiService.CasesServiceSetPriorityOverrideExecute(r)
}

/*
CasesServiceSetPriorityOverride Set priority override

Override a case's computed priority with a specific value.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCasesServiceSetPriorityOverrideRequest
*/
func (a *CasesServiceAPIService) CasesServiceSetPriorityOverride(ctx context.Context, id string) ApiCasesServiceSetPriorityOverrideRequest {
	return ApiCasesServiceSetPriorityOverrideRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SetPriorityOverrideResponse
func (a *CasesServiceAPIService) CasesServiceSetPriorityOverrideExecute(r ApiCasesServiceSetPriorityOverrideRequest) (*SetPriorityOverrideResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetPriorityOverrideResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceSetPriorityOverride")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1/{id}:setPriorityOverride"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setPriorityOverrideRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceUnassignCaseRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	id string
}

func (r ApiCasesServiceUnassignCaseRequest) Execute() (*UnassignCaseResponse, *http.Response, error) {
	return r.ApiService.CasesServiceUnassignCaseExecute(r)
}

/*
CasesServiceUnassignCase Remove case assignment

Remove the current assignee from a case.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCasesServiceUnassignCaseRequest
*/
func (a *CasesServiceAPIService) CasesServiceUnassignCase(ctx context.Context, id string) ApiCasesServiceUnassignCaseRequest {
	return ApiCasesServiceUnassignCaseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return UnassignCaseResponse
func (a *CasesServiceAPIService) CasesServiceUnassignCaseExecute(r ApiCasesServiceUnassignCaseRequest) (*UnassignCaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnassignCaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceUnassignCase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1/{id}:unassign"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCasesServiceUpdateCaseRequest struct {
	ctx context.Context
	ApiService *CasesServiceAPIService
	id string
	casePatch *CasePatch
}

func (r ApiCasesServiceUpdateCaseRequest) CasePatch(casePatch CasePatch) ApiCasesServiceUpdateCaseRequest {
	r.casePatch = &casePatch
	return r
}

func (r ApiCasesServiceUpdateCaseRequest) Execute() (*UpdateCaseResponse, *http.Response, error) {
	return r.ApiService.CasesServiceUpdateCaseExecute(r)
}

/*
CasesServiceUpdateCase Update case fields

Apply a partial update (patch) to a case.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCasesServiceUpdateCaseRequest
*/
func (a *CasesServiceAPIService) CasesServiceUpdateCase(ctx context.Context, id string) ApiCasesServiceUpdateCaseRequest {
	return ApiCasesServiceUpdateCaseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return UpdateCaseResponse
func (a *CasesServiceAPIService) CasesServiceUpdateCaseExecute(r ApiCasesServiceUpdateCaseRequest) (*UpdateCaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateCaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesServiceAPIService.CasesServiceUpdateCase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cases/cases/v1/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.casePatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
