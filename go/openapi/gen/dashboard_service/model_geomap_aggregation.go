/*


No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dashboard_service

import (
	"encoding/json"
	"fmt"
	"gopkg.in/validator.v2"
)

// GeomapAggregation - struct for GeomapAggregation
type GeomapAggregation struct {
	GeomapAggregationAvg *GeomapAggregationAvg
	GeomapAggregationCount *GeomapAggregationCount
	GeomapAggregationMax *GeomapAggregationMax
	GeomapAggregationMin *GeomapAggregationMin
	GeomapAggregationSum *GeomapAggregationSum
}

// GeomapAggregationAvgAsGeomapAggregation is a convenience function that returns GeomapAggregationAvg wrapped in GeomapAggregation
func GeomapAggregationAvgAsGeomapAggregation(v *GeomapAggregationAvg) GeomapAggregation {
	return GeomapAggregation{
		GeomapAggregationAvg: v,
	}
}

// GeomapAggregationCountAsGeomapAggregation is a convenience function that returns GeomapAggregationCount wrapped in GeomapAggregation
func GeomapAggregationCountAsGeomapAggregation(v *GeomapAggregationCount) GeomapAggregation {
	return GeomapAggregation{
		GeomapAggregationCount: v,
	}
}

// GeomapAggregationMaxAsGeomapAggregation is a convenience function that returns GeomapAggregationMax wrapped in GeomapAggregation
func GeomapAggregationMaxAsGeomapAggregation(v *GeomapAggregationMax) GeomapAggregation {
	return GeomapAggregation{
		GeomapAggregationMax: v,
	}
}

// GeomapAggregationMinAsGeomapAggregation is a convenience function that returns GeomapAggregationMin wrapped in GeomapAggregation
func GeomapAggregationMinAsGeomapAggregation(v *GeomapAggregationMin) GeomapAggregation {
	return GeomapAggregation{
		GeomapAggregationMin: v,
	}
}

// GeomapAggregationSumAsGeomapAggregation is a convenience function that returns GeomapAggregationSum wrapped in GeomapAggregation
func GeomapAggregationSumAsGeomapAggregation(v *GeomapAggregationSum) GeomapAggregation {
	return GeomapAggregation{
		GeomapAggregationSum: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *GeomapAggregation) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into GeomapAggregationAvg
	err = newStrictDecoder(data).Decode(&dst.GeomapAggregationAvg)
	if err == nil {
		jsonGeomapAggregationAvg, _ := json.Marshal(dst.GeomapAggregationAvg)
		if string(jsonGeomapAggregationAvg) == "{}" { // empty struct
			dst.GeomapAggregationAvg = nil
		} else {
			if err = validator.Validate(dst.GeomapAggregationAvg); err != nil {
				dst.GeomapAggregationAvg = nil
			} else {
				match++
			}
		}
	} else {
		dst.GeomapAggregationAvg = nil
	}

	// try to unmarshal data into GeomapAggregationCount
	err = newStrictDecoder(data).Decode(&dst.GeomapAggregationCount)
	if err == nil {
		jsonGeomapAggregationCount, _ := json.Marshal(dst.GeomapAggregationCount)
		if string(jsonGeomapAggregationCount) == "{}" { // empty struct
			dst.GeomapAggregationCount = nil
		} else {
			if err = validator.Validate(dst.GeomapAggregationCount); err != nil {
				dst.GeomapAggregationCount = nil
			} else {
				match++
			}
		}
	} else {
		dst.GeomapAggregationCount = nil
	}

	// try to unmarshal data into GeomapAggregationMax
	err = newStrictDecoder(data).Decode(&dst.GeomapAggregationMax)
	if err == nil {
		jsonGeomapAggregationMax, _ := json.Marshal(dst.GeomapAggregationMax)
		if string(jsonGeomapAggregationMax) == "{}" { // empty struct
			dst.GeomapAggregationMax = nil
		} else {
			if err = validator.Validate(dst.GeomapAggregationMax); err != nil {
				dst.GeomapAggregationMax = nil
			} else {
				match++
			}
		}
	} else {
		dst.GeomapAggregationMax = nil
	}

	// try to unmarshal data into GeomapAggregationMin
	err = newStrictDecoder(data).Decode(&dst.GeomapAggregationMin)
	if err == nil {
		jsonGeomapAggregationMin, _ := json.Marshal(dst.GeomapAggregationMin)
		if string(jsonGeomapAggregationMin) == "{}" { // empty struct
			dst.GeomapAggregationMin = nil
		} else {
			if err = validator.Validate(dst.GeomapAggregationMin); err != nil {
				dst.GeomapAggregationMin = nil
			} else {
				match++
			}
		}
	} else {
		dst.GeomapAggregationMin = nil
	}

	// try to unmarshal data into GeomapAggregationSum
	err = newStrictDecoder(data).Decode(&dst.GeomapAggregationSum)
	if err == nil {
		jsonGeomapAggregationSum, _ := json.Marshal(dst.GeomapAggregationSum)
		if string(jsonGeomapAggregationSum) == "{}" { // empty struct
			dst.GeomapAggregationSum = nil
		} else {
			if err = validator.Validate(dst.GeomapAggregationSum); err != nil {
				dst.GeomapAggregationSum = nil
			} else {
				match++
			}
		}
	} else {
		dst.GeomapAggregationSum = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.GeomapAggregationAvg = nil
		dst.GeomapAggregationCount = nil
		dst.GeomapAggregationMax = nil
		dst.GeomapAggregationMin = nil
		dst.GeomapAggregationSum = nil

		return fmt.Errorf("data matches more than one schema in oneOf(GeomapAggregation)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(GeomapAggregation)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src GeomapAggregation) MarshalJSON() ([]byte, error) {
	if src.GeomapAggregationAvg != nil {
		return json.Marshal(&src.GeomapAggregationAvg)
	}

	if src.GeomapAggregationCount != nil {
		return json.Marshal(&src.GeomapAggregationCount)
	}

	if src.GeomapAggregationMax != nil {
		return json.Marshal(&src.GeomapAggregationMax)
	}

	if src.GeomapAggregationMin != nil {
		return json.Marshal(&src.GeomapAggregationMin)
	}

	if src.GeomapAggregationSum != nil {
		return json.Marshal(&src.GeomapAggregationSum)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *GeomapAggregation) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.GeomapAggregationAvg != nil {
		return obj.GeomapAggregationAvg
	}

	if obj.GeomapAggregationCount != nil {
		return obj.GeomapAggregationCount
	}

	if obj.GeomapAggregationMax != nil {
		return obj.GeomapAggregationMax
	}

	if obj.GeomapAggregationMin != nil {
		return obj.GeomapAggregationMin
	}

	if obj.GeomapAggregationSum != nil {
		return obj.GeomapAggregationSum
	}

	// all schemas are nil
	return nil
}

// Get the actual instance value
func (obj GeomapAggregation) GetActualInstanceValue() (interface{}) {
	if obj.GeomapAggregationAvg != nil {
		return *obj.GeomapAggregationAvg
	}

	if obj.GeomapAggregationCount != nil {
		return *obj.GeomapAggregationCount
	}

	if obj.GeomapAggregationMax != nil {
		return *obj.GeomapAggregationMax
	}

	if obj.GeomapAggregationMin != nil {
		return *obj.GeomapAggregationMin
	}

	if obj.GeomapAggregationSum != nil {
		return *obj.GeomapAggregationSum
	}

	// all schemas are nil
	return nil
}

type NullableGeomapAggregation struct {
	value *GeomapAggregation
	isSet bool
}

func (v NullableGeomapAggregation) Get() *GeomapAggregation {
	return v.value
}

func (v *NullableGeomapAggregation) Set(val *GeomapAggregation) {
	v.value = val
	v.isSet = true
}

func (v NullableGeomapAggregation) IsSet() bool {
	return v.isSet
}

func (v *NullableGeomapAggregation) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableGeomapAggregation(val *GeomapAggregation) *NullableGeomapAggregation {
	return &NullableGeomapAggregation{value: val, isSet: true}
}

func (v NullableGeomapAggregation) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableGeomapAggregation) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


