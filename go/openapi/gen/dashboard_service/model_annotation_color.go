/*


No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dashboard_service

import (
	"encoding/json"
	"fmt"
)

// AnnotationColor the model 'AnnotationColor'
type AnnotationColor string

// List of AnnotationColor
const (
	ANNOTATIONCOLOR_ANNOTATION_COLOR_UNSPECIFIED AnnotationColor = "ANNOTATION_COLOR_UNSPECIFIED"
	ANNOTATIONCOLOR_ANNOTATION_COLOR_DEFAULT AnnotationColor = "ANNOTATION_COLOR_DEFAULT"
	ANNOTATIONCOLOR_ANNOTATION_COLOR_GREEN AnnotationColor = "ANNOTATION_COLOR_GREEN"
	ANNOTATIONCOLOR_ANNOTATION_COLOR_CYAN AnnotationColor = "ANNOTATION_COLOR_CYAN"
	ANNOTATIONCOLOR_ANNOTATION_COLOR_BLUE AnnotationColor = "ANNOTATION_COLOR_BLUE"
	ANNOTATIONCOLOR_ANNOTATION_COLOR_PURPLE AnnotationColor = "ANNOTATION_COLOR_PURPLE"
	ANNOTATIONCOLOR_ANNOTATION_COLOR_MAGENTA AnnotationColor = "ANNOTATION_COLOR_MAGENTA"
	ANNOTATIONCOLOR_ANNOTATION_COLOR_RED AnnotationColor = "ANNOTATION_COLOR_RED"
	ANNOTATIONCOLOR_ANNOTATION_COLOR_ORANGE AnnotationColor = "ANNOTATION_COLOR_ORANGE"
	ANNOTATIONCOLOR_ANNOTATION_COLOR_YELLOW AnnotationColor = "ANNOTATION_COLOR_YELLOW"
)

// All allowed values of AnnotationColor enum
var AllowedAnnotationColorEnumValues = []AnnotationColor{
	"ANNOTATION_COLOR_UNSPECIFIED",
	"ANNOTATION_COLOR_DEFAULT",
	"ANNOTATION_COLOR_GREEN",
	"ANNOTATION_COLOR_CYAN",
	"ANNOTATION_COLOR_BLUE",
	"ANNOTATION_COLOR_PURPLE",
	"ANNOTATION_COLOR_MAGENTA",
	"ANNOTATION_COLOR_RED",
	"ANNOTATION_COLOR_ORANGE",
	"ANNOTATION_COLOR_YELLOW",
}

func (v *AnnotationColor) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := AnnotationColor(value)
	for _, existing := range AllowedAnnotationColorEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid AnnotationColor", value)
}

// NewAnnotationColorFromValue returns a pointer to a valid AnnotationColor
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewAnnotationColorFromValue(v string) (*AnnotationColor, error) {
	ev := AnnotationColor(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for AnnotationColor: valid values are %v", v, AllowedAnnotationColorEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v AnnotationColor) IsValid() bool {
	for _, existing := range AllowedAnnotationColorEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to AnnotationColor value
func (v AnnotationColor) Ptr() *AnnotationColor {
	return &v
}

type NullableAnnotationColor struct {
	value *AnnotationColor
	isSet bool
}

func (v NullableAnnotationColor) Get() *AnnotationColor {
	return v.value
}

func (v *NullableAnnotationColor) Set(val *AnnotationColor) {
	v.value = val
	v.isSet = true
}

func (v NullableAnnotationColor) IsSet() bool {
	return v.isSet
}

func (v *NullableAnnotationColor) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableAnnotationColor(val *AnnotationColor) *NullableAnnotationColor {
	return &NullableAnnotationColor{value: val, isSet: true}
}

func (v NullableAnnotationColor) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableAnnotationColor) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

