/*


No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dashboard_service

import (
	"encoding/json"
	"fmt"
	"gopkg.in/validator.v2"
)

// ColorsBy - struct for ColorsBy
type ColorsBy struct {
	ColorsByOneOf *ColorsByOneOf
	ColorsByOneOf1 *ColorsByOneOf1
	ColorsByOneOf2 *ColorsByOneOf2
}

// ColorsByOneOfAsColorsBy is a convenience function that returns ColorsByOneOf wrapped in ColorsBy
func ColorsByOneOfAsColorsBy(v *ColorsByOneOf) ColorsBy {
	return ColorsBy{
		ColorsByOneOf: v,
	}
}

// ColorsByOneOf1AsColorsBy is a convenience function that returns ColorsByOneOf1 wrapped in ColorsBy
func ColorsByOneOf1AsColorsBy(v *ColorsByOneOf1) ColorsBy {
	return ColorsBy{
		ColorsByOneOf1: v,
	}
}

// ColorsByOneOf2AsColorsBy is a convenience function that returns ColorsByOneOf2 wrapped in ColorsBy
func ColorsByOneOf2AsColorsBy(v *ColorsByOneOf2) ColorsBy {
	return ColorsBy{
		ColorsByOneOf2: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *ColorsBy) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into ColorsByOneOf
	err = newStrictDecoder(data).Decode(&dst.ColorsByOneOf)
	if err == nil {
		jsonColorsByOneOf, _ := json.Marshal(dst.ColorsByOneOf)
		if string(jsonColorsByOneOf) == "{}" { // empty struct
			dst.ColorsByOneOf = nil
		} else {
			if err = validator.Validate(dst.ColorsByOneOf); err != nil {
				dst.ColorsByOneOf = nil
			} else {
				match++
			}
		}
	} else {
		dst.ColorsByOneOf = nil
	}

	// try to unmarshal data into ColorsByOneOf1
	err = newStrictDecoder(data).Decode(&dst.ColorsByOneOf1)
	if err == nil {
		jsonColorsByOneOf1, _ := json.Marshal(dst.ColorsByOneOf1)
		if string(jsonColorsByOneOf1) == "{}" { // empty struct
			dst.ColorsByOneOf1 = nil
		} else {
			if err = validator.Validate(dst.ColorsByOneOf1); err != nil {
				dst.ColorsByOneOf1 = nil
			} else {
				match++
			}
		}
	} else {
		dst.ColorsByOneOf1 = nil
	}

	// try to unmarshal data into ColorsByOneOf2
	err = newStrictDecoder(data).Decode(&dst.ColorsByOneOf2)
	if err == nil {
		jsonColorsByOneOf2, _ := json.Marshal(dst.ColorsByOneOf2)
		if string(jsonColorsByOneOf2) == "{}" { // empty struct
			dst.ColorsByOneOf2 = nil
		} else {
			if err = validator.Validate(dst.ColorsByOneOf2); err != nil {
				dst.ColorsByOneOf2 = nil
			} else {
				match++
			}
		}
	} else {
		dst.ColorsByOneOf2 = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.ColorsByOneOf = nil
		dst.ColorsByOneOf1 = nil
		dst.ColorsByOneOf2 = nil

		return fmt.Errorf("data matches more than one schema in oneOf(ColorsBy)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(ColorsBy)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src ColorsBy) MarshalJSON() ([]byte, error) {
	if src.ColorsByOneOf != nil {
		return json.Marshal(&src.ColorsByOneOf)
	}

	if src.ColorsByOneOf1 != nil {
		return json.Marshal(&src.ColorsByOneOf1)
	}

	if src.ColorsByOneOf2 != nil {
		return json.Marshal(&src.ColorsByOneOf2)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *ColorsBy) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.ColorsByOneOf != nil {
		return obj.ColorsByOneOf
	}

	if obj.ColorsByOneOf1 != nil {
		return obj.ColorsByOneOf1
	}

	if obj.ColorsByOneOf2 != nil {
		return obj.ColorsByOneOf2
	}

	// all schemas are nil
	return nil
}

// Get the actual instance value
func (obj ColorsBy) GetActualInstanceValue() (interface{}) {
	if obj.ColorsByOneOf != nil {
		return *obj.ColorsByOneOf
	}

	if obj.ColorsByOneOf1 != nil {
		return *obj.ColorsByOneOf1
	}

	if obj.ColorsByOneOf2 != nil {
		return *obj.ColorsByOneOf2
	}

	// all schemas are nil
	return nil
}

type NullableColorsBy struct {
	value *ColorsBy
	isSet bool
}

func (v NullableColorsBy) Get() *ColorsBy {
	return v.value
}

func (v *NullableColorsBy) Set(val *ColorsBy) {
	v.value = val
	v.isSet = true
}

func (v NullableColorsBy) IsSet() bool {
	return v.isSet
}

func (v *NullableColorsBy) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableColorsBy(val *ColorsBy) *NullableColorsBy {
	return &NullableColorsBy{value: val, isSet: true}
}

func (v NullableColorsBy) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableColorsBy) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


